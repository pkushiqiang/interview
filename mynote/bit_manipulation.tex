\chapter{Bit Manipulation}




\section{Java Tips  }
\subsection{Java Primitive  Types } 


We only list bit manipulation related types.
\begin{table}[ht]
\caption{Java Primitive  Types} % title of Table
\centering % used for centering table
\begin{tabular}{ | c | c | c | c | c |  }
 \hline
          Name   &  size(bits) & minimum    & maximum &  wrapper class   \\
 \hline
          byte   &  8          & -128       &  127    &  java.lang.Byte \\
 \hline
          short   &  16        &  -32,768   &   32,767     &  java.lang.Short \\
 \hline
          int   &   32          & ${-2^{31}}$       &   ${2^{31}-1}$    &  java.lang.Integer \\
 \hline
          long   &  64         & ${-2^{63}}$       &  ${2^{63}-1}$   &  java.lang.Long \\
 \hline
           char   &  16         & 0         &  ${2^{16}-1}$ (65535) &  java.lang.Character \\
 \hline

\end{tabular}
\label{tab:java_types} % is used to refer this table in the text

\end{table} 

\subsection{Two's complement }
In two's complement notation, a non-negative number is represented by its ordinary binary representation; in this case, the most significant bit is 0. Though, the range of numbers represented is not the same as with unsigned binary numbers. For example, an 8-bit unsigned number can represent the values 0 to 255 (11111111). However a two's complement 8-bit number can only represent positive integers from 0 to 127 (01111111), because the rest of the bit combinations with the most significant bit as '1' represent the negative integers -1 to -128.

The two's complement of a negative number is the corresponding positive value. For example, inverting the bits of -5 ( 1111 1011) gives:  \\
0000 0100  \\
And adding one gives the final value:  \\
0000 0101  \\

\subsection{Java bit Operators  }

Some important things we need to remember:
\begin{enumerate}
    \item Java has no signed types like in C/C++    

    \item   ${\sim0}$ is all 1s

    \item In Java using signed \href{http://mitpress.mit.edu/books/introduction-algorithms}{two's complement}  to represent Integer which means the most significant bit is the signed bit, so even a negative number n's 31th bit is 1, ${  ( n \& (1 << 31 ) )}$ still less then zero, so use ${  (  n \& (1 << 31 ) ) >> 31 }$ to get the bit.
        
    \item   Java has singed shift (${>>}$) and unsigned shift  (${>>>}$) operators. In the most case, just use unsigned shift  (${>>>}$).
        
    \item Most bit operation's priority are very low, so add parenthesises around them.  

\end{enumerate}

\begin{table}[ht]
\caption{  bit operation } % title of Table
\centering % used for centering table
\begin{tabular}{ | c | c | c | c  |  }
\hline
                         &  ${ \wedge  }$             &  ${ \&   }$       &  ${ \mid  }$       \\
 \hline
        ${x ~ op ~ 0s  }$    & ${x \wedge 0s =x}$         &  ${x~\&~0s =0}$   &  ${x~\mid~0s = x }$       \\
 \hline
        ${x ~ op ~ 1s  }$    & ${x \wedge 1s = \sim x}$   &  ${x~\&~1s =x}$   &  ${x~\mid~1s = 1s}$        \\
 \hline
        ${x ~ op  ~x  }$     & ${x \wedge x =0 }$         &  ${x~\&~x = x}$   &   ${x~\mid~x = x}$     \\
 \hline
        

\end{tabular}
\label{tab:bit_opt} % is used to refer this table in the text

\end{table}

\subsection{  bit basic tasks  } 

Get basic tasks
\begin{lstlisting} 
    public static int getBit(int num, int pos){
		return ( ( num & (1<<pos) ) >>> pos )> 0 ? 1:0 ;
	}
	
	public static boolean isOne(int num, int pos){
		return ( (num & (1<<pos)) != 0 );
	}
	
	public static int setBitAsOne(int num, int pos){
		 return  ( num | (1<<pos) )  ;
	}
	
	public static int clearBit (int num, int pos){
		 int mask = ~(1<<pos);
		 return num & mask;
	}
	
	public static int flipBits(int num){
		return ~num;
	}
	
	public static int clearBitsMSBthrougthI(int num, int i){
		// 00000111 255, 3
		// inclusive i
		int mask = ( 1 << i) -1;
		return num & mask;
	}
	
	public static int clearBitIBthrougth0(int num, int i){
		// 11110000     255, 3
		// inclusive i
		int mask = ~(  (1 << ( i + 1 )) -1 );
		return num & mask;
	}
	
	public static int updateBit(int num, int pos, int v){
		// 11110000
		int mask = ~(1 << pos );
		return (num & mask) | ( v << pos );
	}

    public static long getUnsignedInt(int x){		
		long mask =  0xffffffffL;
		return   x & mask;		
	}

\end{lstlisting}

More complete bit hack can be found here: 
\href{http://graphics.stanford.edu/~seander/bithacks.html}{Bit Hacks}.

\section{Interview Preparation Books }

 

\section{Interview Questions Leaking }

